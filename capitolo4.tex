%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capitolo 4

\chapter[Implementazione]{Dettagli di Implementazione}
\label{ref:Implementazione}

Questo lavoro di tesi, nello specifico lo sviluppo del componente software, è stato reso possibile, oltre a Wireshark, grazie ad un wrapper di tshark scritto in python chiamato \textit{pyshark}, il quale fornisce delle funzioni d'interfaccia che permettono di catturare/leggere file di cattura, ed accedere ai campi che compongono i vari pacchetti, estraendo informazioni utili.\\
Lo strumento software invece è stato sviluppato in Python nella versione 3, ed è composto da 4 moduli: DropBox\_utils.py, classFrames.py, discriminators\_sets.py, run\_test.py, i quali verranno descritti in dettaglio in questo capitolo.\\

\subsection{\textit{WireShark} (\textit{TShark})}
Software\cite{web:wireshark} Open-Source che permette di catturare il traffico di dati che transita sulla scheda di rete della macchina sulla quale viene mandato in esecuzione, senza la necessità porsi in punti di snodo \qts{centrali}, come Router o Accesspoint. Questo limita molto il traffico dati catturabile, ma permette comunque di ottenere informazioni su tutti i pacchetti inviati/ricevuti a altri dispositivi in Unicast della macchina sulla quale è in esecuzione Wireshark, ed quindi anche tutti i messaggi inviati/ricevuti in Broadcast/Multicast, che per i nostri scopi è più che sufficiente.
Wireshark riesce a \qts{comprendere} la struttura di diversi protocolli di rete, è in grado di individuare eventuali incapsulamenti, riconosce i singoli campi e permette di interpretarne il significato. 
Per la cattura dei pacchetti Wireshark non dispone di proprio codice, ma utilizza libpcap/WinPcap, quindi può funzionare solo su reti supportate da libpcap o WinPcap. \\
??? Mette in condizioni di non rendere visibile al resto della rete che si sta analizzando del traffico dati ... ???.\\ 
\textit{Tshark}, nello specifico, è una utility \qts{a linea di comando} di Wireshark, che utilizza quindi il core del programma principale, offrendo le medesime funzionalità, ed è principalmente usato in tutti quei casi in cui non si necessita di interfaccia grafica, e si richiede output standard(in-line)

\subsection{\textit{Pyshark}\cite{web:pyshark}} 
Wrapper per tshark, reperibile sulla piattaforma GitHub ... ??? .
Non è propriamente un dissector, come molti altri, ma si limita a usare la funzionalità di tshark di esportare XMLs per usare il loro parsing. Questo package permette di estrarre informazioni sia da file di cattura, sia da \qts{catture Live}, utilizzando tutti i dissector di wireshark installati sulla stessa macchina.\\
Ai fini di questo lavoro, è stato usato il parsing su file di cattura precedentemente ottenuti, in quanto un analisi della rete il più completa possibile si ha soltanto dopo un certo quantitativo di pacchetti catturati.\\
Ogni pacchetto viene rappresentato da una struttura dati chiamata \textit{Packet}, la quale suddivide il pacchetto in \textit{Layer}, accessibili tramite indice o \qts{nome}. Un \textit{Layer} contiene tutti i campi che un \qts{layer di un pacchetto} possiede, sotto forma di \textit{LayerField}. In fine, un \textit{LayerField} contiene, nel caso in cui il campo contenga una singola informazione, tutti i dati contenuti in un campo di un layer di un pacchetto; nel caso in cui il campo contenga un gruppo di informazioni, per lo più strutturate a sua volta, tale campo viene suddiviso in più \textit{LayerField}s, ognuno dei quali contiene una lista ... un gran casino ???????????????????????????????

\subsection{Python 3}
Per lo sviluppo del tool di analisi, è stato scelto come linguaggio Python nella versione 3,un linguaggio multi-paradigma, che ha tra i principali obiettivi dinamicità, semplicità e flessibilità. Uno dei motivi che ha portato a sceglierlo come linguaggio da usare, oltre al fatto che supporta la programmazione Object Oriented che permette una maggiore modularità in fase di progettazione e implementazione, è stato il suo supporto nativo a strutture ...??? ... hash-table, qui chiamate \textit{dizionari}. Il Dizionario è la struttura che sta alla base dell'intero tool, e permette di raccogliere informazioni ed accedervi rapidamente e intuitivamente per mezzo delle proprie \qts{chiavi}.\\ Inoltre, Python supporta anche un modo d'uso interattivo attraverso il quale è possibile inserire codice direttamente da un terminale, visualizzando immediatamente il risultato. Questo strumento è stato fondamentale, oltre che in fase di sviluppo e di debug, anche a comprendere il funzionamento e le strutture con le quali \textit{Pyshark} raccoglie le informazioni estratte all'interno dei pacchetti dati in input tramite i file di cattura.

\section{Il Tool di Analisi: Struttura}
Lo strumento sviluppato per la raccolta e l'analisi delle informazioni rilevanti sui dispositivi connessi alla rete è stato strutturato in 3 moduli, ognuno dei quali implementa determinate funzionalità:
\begin{itemize}
	\item[classFrames.py] nel quale sono implementate tutte le classi utili a raccogliere e contenere le informazioni in modo strutturato; inoltre alcune classi implementano le funzioni che svolgono il lavoro di analisi: caratterizzazione e catalogazione dei dispositivi, e interazioni con gli altri nodi della rete.
	\item[DropBox\_util.py] qui viene implementata, nello specifico, la struttura dati che contiene le informazioni ricavate dai pacchetti Dropbox, e quindi tutti i campi dei messaggi db-lsp-disc.
	\item[disc\dots tors\_sets.py] in questo modulo sono raccolte tutte quelle strutture(\textit{insiemi} e \textit{dizionari}) utilizzate per categorizzare i dispositivi nelle varie tipologie scelte in questo lavoro. Inoltre, sono presenti anche dizionari utilizzati per identificare con precisione i dispositivi tramite codice di modello e Sistema Operativo, e dizionari di \qts{keyword} spesso ricorrenti all'interno degli hostnames rilevati, anch'essi usati per attribuite un tipo e un ipotetico proprietario al dispositivo.
	\item[run\_test.py] Questo è il modulo mandato in esecuzione per l'analisi completa del traffico di rete, ed è costituito da una sequenza di istruzioni che, in breve, apre i file di cattura utilizzati per testare l'algoritmo, li analizza passandoli alle funzioni definite negli altri moduli, ed infine stampa a linea di comando i risultati, componendo un'elenco di dispositivi \qts{categorizzati}, seguito da una lista che rappresenta i collegamenti che i suddetti dispositivi hanno fra di loro.
\end{itemize}

Adesso andremo ad analizzare in dettaglio ogni singolo modulo del tool.

\subsection{classFrames.py}
In questo modulo, come già accennato, sono presenti tutte le classi utilizzate per raccogliere in maniera strutturata le informazioni mDNS e analizzarle insieme ai dati ricavati dal protocollo Dropbox
\\

La classe \textbf{\textit{Target}} è rappresentazione strutturata di un target, con le relative porte, al quale riferirsi per fruire di un servizio annunciato nella rete locale, quindi: \textit{nomeHost.local} e \textit{\#Porta} per connettersi al servizio. Offre metodi per aggiornare il numero delle porte e getter per reperire le informazioni.\\

La classe \textbf{\textit{ServiceMDNS}} racchiude tutte le informazioni carpite dai vari record DNS sparsi in tutti i pacchetti reperiti nella rete, quindi che vanno dal nome completo che identifica Istanza e Tipo, ai campi \textit{TXT} opzionali che forniscono dettagli su di esso.  Oltre alle funzioni di \textit{add\_*} e \textit{update\_*} per aggiornare i dettagli del servizio offerto, è stata implementata una funzione interna di utilità, usata per scomporre il nome \qts{composto} del servizio, ottenendo i campi separati di \textit{Istanza}, \textit{Tipo Servizio}, e \textit{Dominio}(e Protocollo usato). Quest'ultima funzione di utilità è mutuata dal fatto che spesso il dissector usato non separa correttamente queste sezioni del nome, solitamente a causa della stringa della sezione \textit{Istanza} che contiene il carattere \qts{.}, inducendo ad una scorretta scomposizione. Per arginare questo problema, nella funzione implementata, la stringa con il nome completo viene \qts{dissezionata} a partire dalla fine di essa, confidando nel fatto che non è presente il carattere \qts{.} all'interno delle sezioni \textit{Dominio} e \textit{Tipo Protocollo} \\

La classe \textbf{\textit{Device}} è la rappresentazione strutturata di tutte le informazioni ricavate su di un dispositivo. I campi che lo compongono sono: \textbf{\textit{id}}, che ne indica il suo MAC-Address; \textbf{\textit{kind}}, che ne rivela la tipologia, e lo si ottiene a seguito dell'analisi di tutti i servizi offerti da questo particolare nodo; \textbf{\textit{owner}} ne indica il presunto possessore del dispositivo, ricavato dall'elaborazione dell'hostname.local; \textbf{\textit{lastIPv4}} e \textbf{\textit{lastIPv6}} sono gli ultimi indirizzi IP v4/v6 che sono stati associati al nodo(al MAC-Address); \textbf{\textit{services}} è una hash-table nella quali sono raccolti tutti i \textit{ServiceMDNS} che sono stati annunciati dal dispositivo, e sono identificati univocamente dal loro nome completo \textit{Istanza.Tipo.Dominio}; \textbf{\textit{alias}} è un'nsieme dove vengono raccolti tutti gli alias con i quali viene identificato il dispositivo, ovvero dall'hostname.local, ai \textit{nomi\_Istanze} dei vari servizi offerti; \textbf{\textit{db\_lsp\_disc}} contiene la struttura dati custom(descritta nel modulo Dropbox\_utils.py) che racchiude tutte le informazioni ricavate dai pacchetti Dropbox, in particolare contiene l'elenco aggiornato di tutti i namespaces annunciati fino a quel momento.\\
Seguono una serie di metodi per aggiornare/aggiungere informazioni riguardanti il dispositivo. In particolare, \textbf{\textit{add\_alias}} è un metodo che, oltre che aggiungere una stringa all'insieme di alias, \qts{ripulisce} la ripulisce e ne riporta il corretto appellativo rimuovendo la parte in cui indica \qts{per quale altro dispositivo sta offrendo il servizio}, ovvero: se un Laptop sta condividendo i servizi di una stampante ad esso collegato, l'alias ricavato dalla stringa \textit{Istanza\_del\_servizio} sarà del tipo:\\
\qts{\textit{StampanteCondivisa @ Laptop\_hostname}}\\
ottenendo come vero alias \qts{\textit{Laptop\_hostname}}. \\
Il metodo usato per attribuire un tipo al dispositivo è chiamato \textit{update\_kind}, e il suo unico scopo è quello di richiamare i metodi di un'altra casse custom, \textit{WhoIsWhat}, descritta a breve.\\

La classe \textbf{\textit{NetworkLAN}} implementa la struttura principale che contiene la lista di tutti i dispositivi riconosciuti, e le loro interazioni.\\
Principalmente è composta da \textbf{\textit{devices}}, un dizionario con i dispositivi aventi come chiave il loro \textit{id}, e \textit{dorpboxSubNET}, un dizionario(sempre con chiavi gli id dei dispositivi) che contiene le liste di tutti i nodi con cui un dispositivo condivide cartelle Dropbox. Per chiarire il concetto, il dizionario \textbf{\textit{dorpboxSubNET}} ha la seguente struttura:
\begin{itemize}
	\item[\qts{id 1} :] \{Insieme di \textit{id} di tutti i dispositivi con i quali condivide una cartella\}
	\item[\qts{id 2} :] \{Insieme di \textit{id} di tutti i dispositivi con i quali condivice una cartella\}
	\item[\qts{id 3} :] \dots
\end{itemize}
Gli altri due dizionari che fanno parte della classe, \textit{lost\_srv\_propertiese} e \textit{namespaces\_in\_common}, sono delle strutture di supporto ai metodi che adesso andremo ad analizzare:\\
\begin{itemize}
	\item \textbf{\textit{extract\_mDNS\_info}} è il metodo che dato un pacchetto, ne ricava le informazioni mDNS utili al nostro lavoro. Il metodo implementa l'algoritmo a pagina \pageref{extract_mDNS_info}, nella sezione in cui viene descritta l'\textit{analisi di un pacchetto mDNS}. Per quanto riguarda l'implementazione, sono tate utilizzate numerose strutture di utilità(liste) a causa della complessa struttura interna con la quale è stata implementata la classe \textit{Packet} fornita da \textit{Pyshark}: ogni record di risposta NON viene contenuto in una singola struttura dati, ma viene diviso in vari \textit{LayerField}s, ognuno dei quali contiene una lista con tutti i sotto-campi dello stesso tipo.\\
	Per chiarire:\\
	Se un pacchetto contiene un'array di record DNS di risposta\footnote{[ Nome | Tipo | Classe(IN) | TTL | Lunghezza |  Dati ]}, ogni record NON è rappresentato da un singolo LayerField contenente tutti i campi di un \textit{record DNS}, ma bensì ci saranno tanti LayerField(quanti sono i campi del \textit{record DNS}) che conterranno ognuno una lista campi del record dello stesso tipo, ottenendo quindi: lista di recod.nomi, lista di recod.tipi, \dots e così via.\\ 
	Questa strutturazione ha comportato un'enorme lavoro per raccolta dati mDNS, e le scelte implementative dell'algoritmo sono state basate su di essa. Come ad esempio il motivo per cui la raccolta di informazioni che risiedono nei record SRV è separata da quella dei record TXT, A, o AAAA, in quanto il nome dei record SRV, come i suoi campi, sono situati in una lista separata dagli altri.\\
	Per concludere la descrizione di questo metodo, si rimanda la visione al prossimo punto nel quale viene descritto il processo con il quale viene \qts{ripulito} il dispositivo da tutti quei servizi che annuncia, ma che non offre direttamente.
	
	\item \textbf{\textit{cleanup}} è un metodo di utilità che, dato un dispositivo, verifica che tutti i servizi da lui annunciati sono a sua volta offerti dallo stesso. Per verificarlo, se ne controlla il \textit{target} a cui riferirsi per usufruire del servizio, che non è però sempre disponibile: per arginare il problema, viene creato un \qts{\textit{target fittizio}}, ricavato dalla sezione \textit{Istanza} del nome del servizio, che comunque identifica un  dispositivo dato che fa anche parte dei vari alias di quest'ultimo; nel caso in cui il servizio sia \textit{condiviso}, e quindi riporti nel nome dell'\textit{Istanza} il carattere \textit{@}, viene elaborato come già descritto nella classe \textit{Device.add\_alias()} in questa sezione.\\
	Proseguendo, se un servizio non è offerto direttamente dal dispositivo, prima si controlla se è stato rilevato un nodo che ne sia il target(controllando fra i suoi alias): in caso positivo si assegna correttamente il \textit{ServiceMDNS}, altrimenti lo si inserisce nella struttura interna \textit{lost\_srv\_propertiese} per mezzo del metodo \textit{add\_lost\_property}.
	\item \textbf{\textit{add\_lost\_property}} si limita ad aggiungere un servizio nella struttura interna \textit{lost\_srv\_propertiese}, indicizzandolo per ogni \textit{Target} attribuito a quel servizio.
	\item  \textbf{\textit{search\_lost\_propertyes}}: metodo che, dato un dispositivo, controlla per ogni suo alias se vi siano servizi indicizzati nella struttura \textit{lost\_srv\_propertiese}, e li aggiunge ai servizi da lui offerti.\\ Questo metodo è usato ogni volta che viene aggiunto un nuovo alias al dispositivo, in modo tale da recuperare eventuali servizi che non sono potuti esser stati assegnati perché magari non era stato ancora associato un particolare alias.
	
	\item \textbf{\textit{extract\_DB\_infos}}, dato un pacchetto, ne ricava le solite informazioni di id(MAC-Addres) e IP v4/v6 del dispositivo, ma non implementa l'estrazione delle informazioni ricavabili da un pacchetto Dropbox: questo è delegato al metodo costruttore della classe \textit{DBlspDISC}, implementata nel modulo \textit{Dropbox\_utils.py}.
	
	\item \textbf{\textit{get\_dropbox\_subNET}}: metodo che ha lo scopo di verificare quali dispositivi condividono cartelle Dropbox con gli altri nodi della rete, e collegarli fra loro, riportando i risultati nella struttura \textit{dorpboxSubNET} e quindi rappresentando la \qts{sottorete} che si viene a creare fra gli utenti Dropbox.\\
	Il processo si divide in 2 fasi: nella prima si creano delle liste, raccolte nella struttura \textit{namespaces\_in\_common}, indicizzate dal \qts{codice} dei \textit{namespace} annunciati nei pacchetti \textit{db-lsp-disc}, all'interno delle quali si trovano tutti gli \textit{id} dei dispositivi che li hanno diffusi; nella seconda fase, per ogni \textit{namespace}, se ne scorre la lista di \textit{id}, per ognuno si crea un'ulteriore lista di id, nella struttura \textit{dorpboxSubNET} che come descritto in precedenza, elenca tutti i dispositivi con i quali quel nodo della rete condivide almeno una cartella.
\end{itemize}

I restanti metodi sono semplici funzioni di utilità per una stampa, formattata a linea di comando, utilizzati per visualizzare all'utente i risultati ottenuti dallo studio.\\

La classe \textbf{\textit{WhoIsWhat}} implementa tutta la parte di \textit{Analisi} delle informazioni raccolte dai pacchetti mDNS, e tenta di classificare il dispositivo dato in input al costruttore della stessa.\\
Contiene delle strutture dati di supporto, quali:\\
\textit{protos}: contiene l'insieme di tutti i \textit{tipi} dei servizi annunciati;\\
\textit{bestMatches}: insieme di categorie a cui potrebbe appartenere il dispositivo sotto analisi;\\
\textit{kindPool}: dizionario che ha come indici le categorie di dispositivi, e come valore associato un intero che indica il \qts{grado di fiducia} con il quale il dispositivo appartiene a l'una o l'altra categoria;\\
\textit{kind}: Risultato dell'analisi, qui viene riportata la categoria che meglio descrive il dispositivo;\\
\textit{rel\_lev}: livello di affidabilità massimo incontrato;\\
\textit{guess\_owner}: qui viene riportato il nome dell'ipotetico proprietario ricavato dal host-name;\\
L'Algoritmo è implementato\footnote{Utilizzando i dizionari definiti nel modulo \textit{discriminators\_sets.py}} nel metodo \textbf{\textit{check}}, e i metodi all'interno utilizzati: \textit{check\_dev\_info}, \textit{check\_on\_local\_alias} e \textit{check\_MDNS\_proto}.\\ L'analisi parte scorrendo l'insieme di servizi annunciati dal dispositivo, durante il quale si verifica la presenza del \qts{servizio fittizio} \textit{\_device-info}. Se presente viene utilizzato il metodo \textbf{\textit{check\_dev\_info}}, il quale non fa altro che recuperare i codici di modello e versione OS dai relativi campi \textit{TXT}(\textit{model} e \textit{osxversion} se presente), e verificare se nelle strutture interne \textit{apple\_products} e \textit{apple\_osx\_versions}\footnote{in quanto questo particolare \qts{servizio} è sfruttato solo dai dispositivi Apple} sia presente un dispositivo indicizzato con quel/quei codice/i, identificando quindi con precisione il dispositivo.\\
Proseguendo nell'algoritmo, si analizzano gli alias del nodo, in particolare quelli della forma \textit{alias\_dev.local}, che ne indicano l'hostname, utilizzando il metodo \textbf{\textit{check\_on\_local\_alias}}: la sua funzione è quella di verificare se è presente una delle \textit{keyword} situate nel dizionario \textit{keyword\_on\_alias}, e in caso positivo assegna la tipologia del dispositivo associata a quella keyword; in oltre, questo metodo tenta di dedurre il possessore del dispositivo, che spesso viene riportato insieme alla parola chiave nell'alias, come accennato nel Capitolo \ref{ref:Lavoro}.\\
Viene poi approntato lo studio sui singoli servizi annunciati, con il metodo \textbf{\textit{check\_MDNS\_proto}}: per ogni servizio si controlla se quel servizio appartiene\footnote{Tramite i dizionari \textit{ALLprot} e \textit{SPECprot}} ad una categoria di dispositivi che solitamente lo annuncia; il controllo avviene in 2 fasi: nella prima si controlla se il servizio appartenga al'insieme di quelli che sicuramente vengono annunciati esclusivamente da un particolare tipo di dispositivo, e se non ne viene rilevato nessuno, allora si passa alla seconda fase, nella quale si allarga il campo controllando in insiemi(sempre indicizzati per categoria) che riportano i servizi probabilmente annunciati da quella categoria, e \qts{il grado di fiducia} con il quale quel servizio è annunciato da quella categoria di dispositivi. Alcuni esempi verranno presentati nella sezione in cui verrà descritto il processo di \textit{validazione del tool}.\\
In fine, con il metodo \textbf{\textit{get\_kind}}, prima di restituire la stringa che riassume l'analisi del dispositivo, vengono effettuati alcuni passaggi per \qts{ripulire} e correggere le informazioni raccolte da eventuali dati che potrebbero indurre ad una errata categorizzazione del dispositivo. In particolare tramite il metodo \textbf{\textit{shared\_printer}}, si controlla se il servizio che ha indotto ad attribuire l'etichetta \qts{Stampante} a questo dispositivo sia un servizio che viene direttamente offerto da quest'ultimo: il caso opposto viene rilegato grazie alla presenza del carattere \qts{\textit{@}} presente nel \textit{nome dell'Istanza} del servizio, come già descritto nel Capitolo \ref{ref:Lavoro}. Al termine di questo processo, si compone una stringa che elenca, separate da \qts{/}, tutte le caratteristiche ricavate da questa analisi, che il dispositivo potrebbe avere.

\subsection{DropBox\_util.py}

All'interno di questo modulo è implementata la classe \textit{\textbf{DBlspDISC}}, che rappresenta una struttura dati che contiene le informazioni recuperate da un pacchetto Dropbox \textit{db-lsp-disc}.\\

Si compone di alcune variabili e strutture dati interne, usate per contenere le informazioni reperite dal pacchetto: \textit{host\_int}, \textit{displayname}, \textit{version} e \textit{port} sotto forma di stringhe; e la più importante per il nostro studio, \textit{namespaces}, implementato per mezzo di un'insieme, e riporta l'elenco dei namespaces, e quindi delle cartelle Dropbox, che l'host ha in condivisione in quel momento. Sono inoltre presenti alcune costanti usate per accedere ai campi.\\

L'intera funzionalità della classe è implementata nel suo costruttore \textbf{\textit{\_\_init\_\_()}}, il quale passatogli un pacchetto\footnote{Nota: in questo caso il pacchetto che gli viene passato deve esser stato ottenuto da una funzione del modulo PyShark con l'opzione/argomento \qts{\textit{use\_json=True}}, altrimenti i dati da recuperare si trovano in un formato illeggibile} recupera l'oggetto json all'interno del quale sono riportate le informazioni da recuperare. Ottenuto l'oggetto Json, ne scorre i campi, salvandosi tutte le informazioni reperite all'interno. \\
I restanti metodi della classe sono dei semplici \textit{getter}, ad eccezione di \textbf{\textit{update\_ns()}} che aggiorna la lista dei \textit{namespaces} di un dispositivo aggiungendone di nuovi.

\subsection{discriminators\_sets.py}

In questo modulo sono raccolte tutte le strutture dati utilizzate per \qts{discriminare} e categorizzare le varie tipologie di dispositivi.\\

La classificazione generale dei dispositivi connessi d una rete locale è stata ridotta a 5 \qts{MACRO-Aree}: in fase di progettazione è stato deciso di non specializzarsi ulteriormente in Classi più specifiche, in quanto, dato le informazioni prese in esame, si rischierebbe di incorrere ad una categorizzazione errata e non accurata come quella utilizzata per questo studio.\\
Le \qts{\textit{Classi}} con le quali si suddividono i dispositivi sono: \textit{WORKSTATION}, \textit{NAS}, \textit{PRINTER}, \textit{MOBILE}, \textit{MEDIA}.\\
Per quando riguarda la caratterizzazione di ogni gruppo si rimanda al Capitolo \ref{ref:Lavoro}, dove viene descritto ogni Categoria.\\

Le suddette categorie sono tate usate per indicizzare gli insiemi di protocolli che li caratterizzano in 2 strutture dati(\textit{hash-table} o come vengono chiamati in Python \textit{dizionari}): \textbf{\textit{ALLprot}} che è il più generico dove sono raccolti, raggruppati per categoria, tutti quei servizi che \qts{\textit{molto probabilmente}} vengono annunciati da quella categoria di dispositivi, e ad ogni servizio è associato un \qts{\textit{grado di fiducia}} con il quale si indica la probabilità che quel servizio sia annunciato da quel tipo di dispositivo; \textbf{\textit{SPECprot}} è l'hash-table, sempre suddivisa come la precedente, che riporta i servizi suddivisi per categoria che sicuramente(o quasi) sono annunciati esclusivamente da quella \qts{specifica} categoria di dispositivi.\\
La scarsa quantità di documentazione riguardo i servizi DNS-SD ha portato ad un considerevole lavoro per capire quali vengano annunciati da alcune categorie rispetto che ad altre. Questo è dovuto anche al fatto che molti di essi non siano veri e propri \textit{standard}, ma bensì proprietari, impedendo uno studio approfondito riguardo il loro utilizzo e le modalità con cui venissero annunciati. Anche per tutti quei servizi indicati come \qts{standard}, spesso si incorre in situazioni poco chiare riguardo al \qts{chi annuncia quel servizio}, o magari se quel determinato servizio viene annunciato \qts{per conto di altri}, come nel caso affrontato per le stampanti. Lo studio quindi ha necessitato di un pò di deduzione logica e interpretazione umana per assegnare un servizio ad una categoria rispetto che ad un altra, non limitandosi alla pura \qts{appartenenza ad una classe}, ma come descritto nella sezione precedente, è stano necessario una certa elaborazione, in alcuni casi specifica al determinato servizio. Ulteriori dettagli verranno discussi nella descrizione della fase di validazione.\\

Altre 2 hash-tables, \textbf{\textit{apple\_products}} e \textbf{\textit{apple\_osx\_versions}}, sono invece state utilizzate per identificare con esattezza modello e Sistema Operativo dei dispositivi Apple che diffondono il \qts{servizio} \textit{\_device-info}, e che riporta nei record TXT associati: il numero del modello e opzionalmente l'identificativo della versione dell'OS che in quel momento è in esecuzione su quella macchina. Grazie a ntop??? ...\\

Le ultime strutture sono adibite all'analisi e alla scomposizione dell'\textit{hostname.local} annunciati dai dispositivi nei record di risposta mDNS di tipo A o di tipo AAAA.\\
La prima è un'insieme di \textit{dizionari}, sempre indicizzati dalle Categorie di dispositivi precedentemente descritte, chiamato \textbf{\textit{keyword\_on\_alias}}, all'interno del quale, per ogni categoria, è presente un ulteriore dizionario che contiene le coppie \textit{<chiave, valore>}, dove \textit{chiave} rappresenta appunto la keyword che solitamente è presente negli hostname di quel tipo, e \textit{valore} è una stringa che descrive brevemente quale è il dispositivo che riporta quella keyword nel proprio nome.\\
Le ultime 2, \textbf{\textit{common\_string}} e \textbf{\textit{common\_string\_s}} sono liste ordinate di \qts{stringhe comuni} che solitamente compongono l'hostname.local, e sono utilizzate per \qts{ripulire} la stringa ed ottenere un \textit{nominativo} al quale attribuire il ruolo di \qts{possessore del dispositivo}. Questo processo è stato una conseguenza dello studio dei vari hostnames annunciati nelle reti utilizzate per la cattura di traffico dati in fase di sviluppo, test, e validazione, raccogliendo quindi i pattern di stringhe più comuni ed ottenendo dei risultati tutto sommato accettabili in fase di validazione, e identificando nella maggior parte dei casi il nome corretto del possessore del dispositivo.\\

\subsection{run\_test.py}

Modulo utilizzato principalmente in fase di \textit{test} e di \textit{debug}, ma che tutto sommato ne è un \qts{\textit{template}} dal quale se ne può ricavare un tutorial di utilizzo dello strumento sviluppato per questo lavoro di tesi.\\

Non è altro che una sequenza di istruzioni, le quali creano un'istanza della classe principale \textit{NetworkLAN}, aprono una serie di file di cattura tramite la funzione offerta da Pyshark \textit{pyshark.FileCapture()} nei 2 rispettivi modi\footnote{[!]Come accennato in precedenza, l'utilizzo di ognuna delle 2 opzioni implica la possibilità di recuperare facilmente le informazioni di un tipo(mDNS/Dropbox), impossibilitando il recupero delle informazioni dell'altro. Per ulteriori dettagli, riferirsi alla documentazione\cite{web:pyshark} di PyShark reperibile in rete} con cui codifica i pacchetti restituiti: \textit{use\_json=False} per recuperare le informazioni mDNS, e \textit{use\_json=True} per ottenere i dati nei campi dei pacchetti Dropbox db-lsp-disc.

\section{Validazione}

Il processo di validazione approntato per questo Lavoro di Tesi è partito da un'analisi sulla completezza riguardo il materiale reperibile a proposito dei protocolli presi in esame, quali mDNS e DB-LSP-DISC, e rispetto ai risultati ottenuti nei test.\\

Per quanto riguarda lo studio del protocollo \textit{mDNS}, il punto di partenza è stato l'analizzare numerosi \textit{RFC} a riguardo, a partire dalla definizione dello \textit{standard} del protocollo, reperibile in RFC6762\cite{mDNS}, nel quale viene appunto fornita una traccia dello Standard mDNS. In questo documento ne vengono descritti i comportamenti, come i meccanismi di \textit{query-response}, le modalità con cui i dispositivi che utilizzano il protocollo si annunciano in rete, si scambiano dati. Inoltre viene riportato il dettaglio delle informazioni che se ne possano ricavare, il formato con cui vengono diffuse, e i campi del pacchetto nei quali reperirle.\\
Altri RFC analizzati riguardo mDNS sono stati \textit{RFC6973} e \textit{RFC8386}, nei quali sono state fatte numerose considerazioni riguardo la \textit{Privacy} dei protocolli Broadcast e Multicast, e più in generale del traffico Internet. Questi documenti si possono considerare come lo spunto principale dal quale ne è scaturito questo lavoro di Tesi, in quanto ne è effettivamente una constatazione di quali informazioni si riescono ad acquisire dai protocolli Broadcase/Multicast.\\

Per quanto riguarda i tipi di servizi annunciati tramite i record \textit{DNS-SD}, nel corso dello studio preliminare e raccolta di informazioni, è stato analizzato l'elenco dei \qts{\textit{servizi dichiarati}} dall'organizzazione \textit{Internet Assigned Numbers Authority}, conosciuto come IANA\cite{IANA}. Per ovvie ragioni tempo, non sono stati visionati ed utilizzati tutti i servizi dichiarati in questa raccolta, anche dato che la probabilità di imbattersi in molti di loro è molto bassa, e per quasi la totalità sono servizi sì \textit{dichiarati} in questo elenco, ma sono servizi proprietari, e i loro comportamenti e interazioni fra chi li annuncia e chi ne usufruisce molto spesso non sono documentati. Per questi motivi, ci si è affidati ad alcune \qts{liste più ristrette} di servizi, le quali riportavano quelli \qts{più comunemente utilizzati}. 
Per ampliare queste liste e rendere questo studio \textit{completo}, per lo meno per quanto riguarda gli ambienti sui quali è stata testata la funzionalità del tool sviluppato per questo studio, è stata raccolta documentazione anche riguardo tutti quei servizi riscontrati nelle catture del traffico di rete, utilizzate in fase di sviluppo.\\
Questo approccio, per quanto di primo impatto possa considerarsi impreciso e incompleto, ha prodotto degli ottimi risultati in fase di test e validazione, riuscendo a catalogare \textit{correttamente} la totalità dei dispositivi rilevati in questa fase, provando la bontà dell'elaborato.\\
In sintesi, l'iter che ha portato al \qts{popolamento} degli insiemi di servizi annunciati tramite mDNS-DS è stato: partire da un elenco di servizi comunemente usati, e in fase di sviluppo e di test, aggiunti man di mano tutti quelli nuovi incontrati e che non ne facevano parte inizialmente, utilizzandoli nella categorizzazione dei dispositivi dopo uno studio a riguardo sul singolo servizio da aggiungere.\\

La raccolta di materiale inerenti ai pacchetti di Dropbox \textit{Discovery} è partita dall'analisi del documento/guida \qts{\textit{Namespace Guide}}\cite{web:dropboxNS}, reperibile online sul sito della compagnia Dropbox nella sezioni sviluppatori. Tale documento riporta la natura e l'implementazione dei \qts{Namespaces}, fornendo dettagli su come sfruttate tali informazioni ai nostri scopi: scoprire le relazioni fra i dispositivi presenti nella rete locale.\\
La guida copre argomenti avanzati relativi a cartelle e file condivisi di varia natura, dalle \textit{Shared Folders}, \textit{Team Folders} e \textit{Team Spaces \& Member Folders} per i Business Accounts. Lo scopo del documento è quello di fornire una guida all'utilizzo dell'API di Dropbox, quindi non esattamente inerente al nostro lavoro, ma fornisce comunque un'ottima spiegazione riguardo al \qts{cosa sono i namespaces}, da cosa vengono ricavati, cosa rappresentano, e soprattutto quali informazioni si possono dedurre da essi.\\

Riguardo la completezza delle informazioni sulle quali si basa l'analisi del tool, si può concludere che i dati raccolti rappresentano sicuramente la totalità delle informazioni ricavabili dal traffico di una rete locale. Questo è mutuato dal fatto che se, come nelle reti di calcolatori spesso accade, viene perso un pacchetto, o magari non viene rilevato dallo strumento di cattura, il pacchetto viene comunque ritrasmesso ogni 30 secondi circa, come prevedono i protocolli presi in esame(mDNS e DB-LSP-DISC). Quindi effettuando una cattura di pochi minuti si ha la certezza di aver raccolto tutte le informazioni che possono circolare in quel dato momento all'interno di una rete locale.\\
Anche per quanto riguarda il recupero e la codifica degli stessi dati non è stato un problema, in quanto tutte le informazioni dei protocolli analizzati vengono trasmesse in chiaro e a tutti i dispositivi connessi, ed è proprio uno dei punti di partenza di questo studio. Come già accennato in precedenza, il punto di forza di questa analisi è proprio la \qts{discrezione} e la facilità con la quale si ottengono informazioni private dai dispositivi.\\

Analizzando il modo con cui vengono classificati i dispositivi, si evince anche l'affidabilità della classificazione, giustificata da varie considerazioni e derivata da più elaborazioni sequenziali dei dati di natura differente, portando quindi a convergere verso una corretta deduzione sul tipo di dispositivo.\\
Uno dei punti di forza della corretta classificazione è appunto il grado \qts{affidabilità} associato ad ogni informazione in base al quale il tool assegna una \textit{classe} rispetto che un'altra ad un dispositivo. Ad esempio, se un nodo riporta nel suo hostname una keyword evocativa, che potrebbe indurre ad una classificazione corretta come errata, non gli viene associato direttamente quella classificazione, ma si va a verificare tale informazione analizzando i servizi che esso annuncia, e quindi solo allora viene etichettato il dispositivo con la corretta classe. Anche l'informazione riguardante \textit{modello} e \textit{versione OS} viene comunque verificata analizzando gli altri servizi offerti.\\
Anche la scelta delle keyword non è casuale, ma bensì è frutto di numerose catture e verifiche in fase di sviluppo, riportando solo le parole chiave che effettivamente potessero essere usate come discriminanti per i vari dispositivi, e solo dopo un'attenta verifica che quella determinata keyword appartenga effettivamente a quella particolare categoria o a quel particolare dispositivo nello specifico.\\
Per validare tutte queste considerazioni, oltre che ad eseguire il tool in ambienti eterogenei e che presentassero un pò la totalità delle situazioni che si possano riscontrare nella realtà, sono stati sia raccolti dati in ambienti controllati e \qts{conosciuti}, quindi avendo ben presente le tipologie di dispositivi che facessero parte della rete locale, sia verificando di persona, direttamente sul dispositivo identificato, che l'analisi effettuata su di esso fosse corretta, categorizzandolo nel giusto modo, e dove fosse stato possibile, dedurre correttamente nome e cognome del proprietario che in quel momento lo utilizzava.

\subsection{Analisi dei Risultati}

Di seguito vengono riportati alcuni risultati, omettendo opportunamente alcune informazioni ai fini di tutelare la sicurezza e la privacy di persone e reti nella quale è stata effettuata la cattura.\\

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{001_ipad}
	\caption{Esempio di analisi di un dispositivo\label{fig:ipad}}
\end{figure}

In questo esempio si nota come sia il nome, sia la diffusione del record \qts{\_device-info} vengono utilizzati per dedurre Tipo del dispositivo e \qts{ipotetico possessore}.\\

Un'altro esempio che vale la pena osservare è il seguente, nel quale viene rilevato un dispositivo mobile, dando addirittura un \textit{Cognome} al possessore(non riportato interamente per motivi di privacy).
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{002_iphone}
	\caption{Dispositivo mobile\label{fig:iphone}}
\end{figure}
\\
Interessante notare il fatto che non è solo l'\textit{hostname} che attribuisce la categoria al dispositivo, ma tale supposizione viene comunque confermata dal servizio \textit{\_apple-mobdev2}, che rientra nella categoria di tutti quei servizi che vengono diffusi dai dispositivi mobili Apple.\\

Di completamente differente categoria è la rilevazione di una stampante, la quale oltre che al modello e produttore, diffonde numerose informazioni \qts{private}, che magari un eventuale intruso nella rete potrebbe sfruttare.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{004_printer}
	\caption{Stampante collegata in rete\label{fig:printer_info}}
\end{figure}

Il prossimo esempio dimostra la validità con cui sono state suddivise le categorie di servizi che ogni tipologia di dispositivo annuncia, che anche senza l'ausilio del rilevare la keyword \qts{\textit{NAS}} all'interno dell'hostname, ha correttamente identificato il nodo della rete come NAS analizzando solo i servizi dichiarati dalla macchina.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{006_nas}
	\caption{Dispositivo adibito a Network Attached Storage\label{fig:nas}}
\end{figure}

Nel complesso, in tutti i file di cattura utilizzati per testare il tool sviluppato per questo lavoro, sono stati rilevati un totale di 160 dispositivi classificandoli correttamente 156, e restando nell'incertezza, a causa di informazioni non sufficientemente caratterizzanti, con solo 4 dispositivi. Sono state quindi rilevati: 99 Workstation, di cui 16 Personal computer Apple, e ben 88 dei quali aventi Dropbox in esecuzione in quel momento; 15 NAS, di cui 7 Time Capsule; 17 dispositivi Mobili, suddivisi in 5 iPhone, 7 iPad e 7 Android; 29 Stampanti, rilevando 2 dispositivi che ne condividevano almeno una.\\

Dropbox ...
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\linewidth]{007_graficoDB}
	\caption{Dispositivo adibito a Network Attached Storage\label{fig:grafDB}}
\end{figure}