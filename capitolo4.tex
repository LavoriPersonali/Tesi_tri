%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Capitolo 4

\chapter[Implementazione]{Dettagli di Implementazione}
\label{ref:Implementazione}

Questo lavoro di tesi, nello specifico lo sviluppo del componente software, è stato reso possibile, oltre a Wireshark, grazie ad un wrapper di tshark scritto in python chiamato \textit{pyshark}, il quale fornisce delle funzioni d'interfaccia che permettono di catturare/leggere file di cattura, ed accedere ai campi che compongono i vari pacchetti, estraendo informazioni utili.\\
Lo strumento software invece è stato sviluppato in Python nella versione 3, ed è composto da 4 moduli: DropBox\_utils.py, classFrames.py, discriminators\_sets.py, run\_test.py, i quali verranno descritti in dettaglio in questo capitolo.\\

\subsection{\textit{WireShark} (\textit{TShark})}
Software Open-Source che permette di catturare il traffico di dati che transita sulla scheda di rete della macchina sulla quale è mandato in esecuzione, senza la necessità porsi in punti di snodo \qts{centrali}, come Router o Accesspoint. Questo limita molto il traffico dati catturabile, ma permette comunque di ottenere informazioni su tutti i pacchetti inviati/ricevuti a altri dispositivi in Unicast della macchina sulla quale è in esecuzione Wireshark, ed quindi anche tutti i messaggi inviati/ricevuti in Broadcast/Multicast, che per i nostri scopi è più che sufficiente.
Wireshark riesce a \qts{comprendere} la struttura di diversi protocolli di rete, è in grado di individuare eventuali incapsulamenti, riconosce i singoli campi e permette di interpretarne il significato. 
Per la cattura dei pacchetti Wireshark non dispone di proprio codice, ma utilizza libpcap/WinPcap, quindi può funzionare solo su reti supportate da libpcap o WinPcap. \\
??? Mette in condizioni di non rendere visibile al resto della rete che si sta analizzando del traffico dati ... ???.\\ 
\textit{Tshark}, nello specifico, è una utility \qts{a linea di comando} di Wireshark, che utilizza quindi il core del programma principale, offrendo le medesime funzionalità, ed è principalmente usato in tutti quei casi in cui non si necessita di interfaccia grafica, e si richiede output standard(in-line)

\subsection{\textit{Pyshark}} 
Wrapper per tshark, reperibile sulla piattaforma GitHub ... .
Non è propriamente un dissector, come molti altri, ma si limita a usare la funzionalità di tshark di esportare XMLs per usare il loro parsing. Questo package permette il parsing sia da file di cattura, sia da \qts{catture Live}, utilizzando tutti i dissector di wireshark installati sulla stessa macchina.\\
Ai fini di questo lavoro, è stato usato il parsing su file di cattura precedentemente ottenuti, in quanto un analisi della rete il più completa possibile si ha soltanto dopo un certo quantitativo di pacchetti catturati.\\
Ogni pacchetto viene rappresentato da una struttura dati chiamata \textit{Packet}, la quale suddivide il pacchetto in \textit{Layer}, accessibili tramite indice o \qts{nome}. Un \textit{Layer} contiene tutti i campi che un \qts{layer di un pacchetto} possiede, sotto forma di \textit{LayerField}. In fine, un \textit{LayerField} contiene, nel caso in cui il campo contenga una singola informazione, tutti i dati contenuti in un campo di un layer di un pacchetto; nel caso in cui il campo contenga un gruppo di informazioni, per lo più strutturate a sua volta, tale campo viene suddiviso in più \textit{LayerField}s, ognuno dei quali contiene una lista ... un gran casino ???????????????????????????????

\subsection{Python 3}
Per lo sviluppo del tool di analisi, è stato scelto come linguaggio Python nella versione 3,un linguaggio multi-paradigma, che ha tra i principali obiettivi dinamicità, semplicità e flessibilità. Uno dei motivi che ha portato a sceglierlo come linguaggio da usare, oltre al fatto che supporta la programmazione Object Oriented che permette una maggiore modularità in fase di progettazione e implementazione, è stato il suo supporto nativo a strutture ... hash-table, qui chiamate \textit{dizionari}. Il Dizionario è la struttura che sta alla base dell'intero tool, e permette di raccogliere informazioni ed accedervi rapidamente e intuitivamente per mezzo delle proprie \qts{chiavi}.\\ Inoltre, Python supporta anche un modo d'uso interattivo attraverso il quale è possibile inserire codice direttamente da un terminale, visualizzando immediatamente il risultato. Questo strumento è stato fondamentale, oltre che in fase di sviluppo e di debug, anche a comprendere il funzionamento e le strutture con le quali \textit{Pyshark} raccoglie le informazioni estratte all'interno dei pacchetti dati in input tramite i file di cattura.

\section{Il Tool di Analisi: Struttura}
Lo strumento sviluppato per la raccolta e l'analisi delle informazioni rilevanti sui dispositivi connessi alla rete è stato strutturato in 3 moduli, ognuno dei quali implementa determinate funzionalità:
\begin{itemize}
	\item[classFrames.py] nel quale sono implementate tutte le classi utili a raccogliere e contenere le informazioni in modo strutturato; inoltre alcune classi implementano le funzioni che svolgono il lavoro di analisi: caratterizzazione e catalogazione dei dispositivi, e interazioni con gli altri nodi della rete.
	\item[DropBox\_util.py] qui viene implementata, nello specifico, la struttura dati che contiene le informazioni ricavate dai pacchetti Dropbox, e quindi tutti i campi dei messaggi db-lsp-disc.
	\item[disc\dots tors\_sets.py] in questo modulo sono raccolte tutte quelle strutture(\textit{insiemi} e \textit{dizionari}) utilizzate per categorizzare i dispositivi nelle varie tipologie scelte in questo lavoro. Inoltre, sono presenti anche dizionari utilizzati per identificare con precisione i dispositivi tramite codice di modello e Sistema Operativo, e dizionari di \qts{keyword} spesso ricorrenti all'interno degli hostnames rilevati, anch'essi usati per attribuite un tipo e un ipotetico proprietario al dispositivo.
	\item[run\_test.py] Questo è il modulo mandato in esecuzione per l'analisi completa del traffico di rete, ed è costituito da una sequenza di istruzioni che, in breve, apre i file di cattura utilizzati per testare l'algoritmo, li analizza passandoli alle funzioni definite negli altri moduli, ed infine stampa a linea di comando i risultati, componendo un'elenco di dispositivi \qts{categorizzati}, seguito da una lista che rappresenta i collegamenti che i suddetti dispositivi hanno fra di loro.
\end{itemize}

Adesso andremo ad analizzare in dettaglio ogni singolo modulo del tool.

\subsection{classFrames.py}
In questo modulo, come già accennato, sono presenti tutte le classi utilizzate per raccogliere in maniera strutturata le informazioni mDNS e analizzarle insieme ai dati ricavati dal protocollo Dropbox
\\

La classe \textbf{\textit{Target}} è rappresentazione strutturata di un target, con le relative porte, al quale riferirsi per fruire di un servizio annunciato nella rete locale, quindi: \textit{nomeHost.local} e \textit{\#Porta} per connettersi al servizio. Offre metodi per aggiornare il numero delle porte e getter per reperire le informazioni.\\

La classe \textbf{\textit{ServiceMDNS}} racchiude tutte le informazioni carpite dai vari record DNS sparsi in tutti i pacchetti reperiti nella rete, quindi che vanno dal nome completo che identifica Istanza e Tipo, ai campi \textit{TXT} opzionali che forniscono dettagli su di esso.  Oltre alle funzioni di \textit{add\_*} e \textit{update\_*} per aggiornare i dettagli del servizio offerto, è stata implementata una funzione interna di utilità, usata per scomporre il nome \qts{composto} del servizio, ottenendo i campi separati di \textit{Istanza}, \textit{Tipo Servizio}, e \textit{Dominio}(e Protocollo usato). Quest'ultima funzione di utilità è mutuata dal fatto che spesso il dissector usato non separa correttamente queste sezioni del nome, solitamente a causa della stringa della sezione \textit{Istanza} che contiene il carattere \qts{.}, inducendo ad una scorretta scomposizione. Per arginare questo problema, nella funzione implementata, la stringa con il nome completo viene \qts{dissezionata} a partire dalla fine di essa, confidando nel fatto che non è presente il carattere \qts{.} all'interno delle sezioni \textit{Dominio} e \textit{Tipo Protocollo} \\

La classe \textbf{\textit{Device}} è la rappresentazione strutturata di tutte le informazioni ricavate su di un dispositivo. I campi che lo compongono sono: \textbf{\textit{id}}, che ne indica il suo MAC-Address; \textbf{\textit{kind}}, che ne rivela la tipologia, e lo si ottiene a seguito dell'analisi di tutti i servizi offerti da questo particolare nodo; \textbf{\textit{owner}} ne indica il presunto possessore del dispositivo, ricavato dall'elaborazione dell'hostname.local; \textbf{\textit{lastIPv4}} e \textbf{\textit{lastIPv6}} sono gli ultimi indirizzi IP v4/v6 che sono stati associati al nodo(al MAC-Address); \textbf{\textit{services}} è una hash-table nella quali sono raccolti tutti i \textit{ServiceMDNS} che sono stati annunciati dal dispositivo, e sono identificati univocamente dal loro nome completo \textit{Istanza.Tipo.Dominio}; \textbf{\textit{alias}} è un'nsieme dove vengono raccolti tutti gli alias con i quali viene identificato il dispositivo, ovvero dall'hostname.local, ai \textit{nomi\_Istanze} dei vari servizi offerti; \textbf{\textit{db\_lsp\_disc}} contiene la struttura dati custom(descritta nel modulo Dropbox\_utils.py) che racchiude tutte le informazioni ricavate dai pacchetti Dropbox, in particolare contiene l'elenco aggiornato di tutti i namespaces annunciati fino a quel momento.\\
Seguono una serie di metodi per aggiornare/aggiungere informazioni riguardanti il dispositivo. In particolare, \textbf{\textit{add\_alias}} è un metodo che, oltre che aggiungere una stringa all'insieme di alias, \qts{ripulisce} la ripulisce e ne riporta il corretto appellativo rimuovendo la parte in cui indica \qts{per quale altro dispositivo sta offrendo il servizio}, ovvero: se un Laptop sta condividendo i servizi di una stampante ad esso collegato, l'alias ricavato dalla stringa \textit{Istanza\_del\_servizio} sarà del tipo:\\
\qts{\textit{StampanteCondivisa @ Laptop\_hostname}}\\
ottenendo come vero alias \qts{\textit{Laptop\_hostname}}. \\
Il metodo usato per attribuire un tipo al dispositivo è chiamato \textit{update\_kind}, e il suo unico scopo è quello di richiamare i metodi di un'altra casse custom, \textit{WhoIsWhat}, descritta a breve.\\

La classe \textbf{\textit{NetworkLAN}} implementa la struttura principale che contiene la lista di tutti i dispositivi riconosciuti, e le loro interazioni.\\
Principalmente è composta da \textbf{\textit{devices}}, un dizionario con i dispositivi aventi come chiave il loro \textit{id}, e \textit{dorpboxSubNET}, un dizionario(sempre con chiavi gli id dei dispositivi) che contiene le liste di tutti i nodi con cui un dispositivo condivide cartelle Dropbox. Per chiarire il concetto, il dizionario \textbf{\textit{dorpboxSubNET}} ha la seguente struttura:
\begin{itemize}
	\item[\qts{id 1} :] \{Insieme di \textit{id} di tutti i dispositivi con i quali condivide una cartella\}
	\item[\qts{id 2} :] \{Insieme di \textit{id} di tutti i dispositivi con i quali condivice una cartella\}
	\item[\qts{id 3} :] \dots
\end{itemize}
Gli altri due dizionari che fanno parte della classe, \textit{lost\_srv\_propertiese} e \textit{namespaces\_in\_common}, sono delle strutture di supporto ai metodi che adesso andremo ad analizzare:\\
\begin{itemize}
	\item \textbf{\textit{extract\_mDNS\_info}} è il metodo che dato un pacchetto, ne ricava le informazioni mDNS utili al nostro lavoro. Il metodo implementa l'algoritmo a pagina \pageref{extract_mDNS_info}, nella sezione in cui viene descritta l'\textit{analisi di un pacchetto mDNS}. Per quanto riguarda l'implementazione, sono tate utilizzate numerose strutture di utilità(liste) a causa della complessa struttura interna con la quale è stata implementata la classe \textit{Packet} fornita da \textit{Pyshark}: ogni record di risposta NON viene contenuto in una singola struttura dati, ma viene diviso in vari \textit{LayerField}s, ognuno dei quali contiene una lista con tutti i sotto-campi dello stesso tipo.\\
	Per chiarire:\\
	Se un pacchetto contiene un'array di record DNS di risposta\footnote{[ Nome | Tipo | Classe(IN) | TTL | Lunghezza |  Dati ]}, ogni record NON è rappresentato da un singolo LayerField contenente tutti i campi di un \textit{record DNS}, ma bensì ci saranno tanti LayerField(quanti sono i campi del \textit{record DNS}) che conterranno ognuno una lista campi del record dello stesso tipo, ottenendo quindi: lista di recod.nomi, lista di recod.tipi, \dots e così via.\\ 
	Questa strutturazione ha comportato un'enorme lavoro per raccolta dati mDNS, e le scelte implementative dell'algoritmo sono state basate su di essa. Come ad esempio il motivo per cui la raccolta di informazioni che risiedono nei record SRV è separata da quella dei record TXT, A, o AAAA, in quanto il nome dei record SRV, come i suoi campi, sono situati in una lista separata dagli altri.\\
	Per concludere la descrizione di questo metodo, si rimanda la visione al prossimo punto nel quale viene descritto il processo con il quale viene \qts{ripulito} il dispositivo da tutti quei servizi che annuncia, ma che non offre direttamente.
	
	\item \textbf{\textit{cleanup}} è un metodo di utilità che, dato un dispositivo, verifica che tutti i servizi da lui annunciati sono a sua volta offerti dallo stesso. Per verificarlo, se ne controlla il \textit{target} a cui riferirsi per usufruire del servizio, che non è però sempre disponibile: per arginare il problema, viene creato un \qts{\textit{target fittizio}}, ricavato dalla sezione \textit{Istanza} del nome del servizio, che comunque identifica un  dispositivo dato che fa anche parte dei vari alias di quest'ultimo; nel caso in cui il servizio sia \textit{condiviso}, e quindi riporti nel nome dell'\textit{Istanza} il carattere \textit{@}, viene elaborato come già descritto nella classe \textit{Device.add\_alias()} in questa sezione.\\
	Proseguendo, se un servizio non è offerto direttamente dal dispositivo, prima si controlla se è stato rilevato un nodo che ne sia il target(controllando fra i suoi alias): in caso positivo si assegna correttamente il \textit{ServiceMDNS}, altrimenti lo si inserisce nella struttura interna \textit{lost\_srv\_propertiese} per mezzo del metodo \textit{add\_lost\_property}.
	\item \textbf{\textit{add\_lost\_property}} si limita ad aggiungere un servizio nella struttura interna \textit{lost\_srv\_propertiese}, indicizzandolo per ogni \textit{Target} attribuito a quel servizio.
	\item  \textbf{\textit{search\_lost\_propertyes}}: metodo che, dato un dispositivo, controlla per ogni suo alias se vi siano servizi indicizzati nella struttura \textit{lost\_srv\_propertiese}, e li aggiunge ai servizi da lui offerti.\\ Questo metodo è usato ogni volta che viene aggiunto un nuovo alias al dispositivo, in modo tale da recuperare eventuali servizi che non sono potuti esser stati assegnati perché magari non era stato ancora associato un particolare alias.
	
	\item \textbf{\textit{extract\_DB\_infos}}, dato un pacchetto, ne ricava le solite informazioni di id(MAC-Addres) e IP v4/v6 del dispositivo, ma non implementa l'estrazione delle informazioni ricavabili da un pacchetto Dropbox: questo è delegato al metodo costruttore della classe \textit{DBlspDISC}, implementata nel modulo \textit{Dropbox\_utils.py}.
	
	\item \textbf{\textit{get\_dropbox\_subNET}}: metodo che ha lo scopo di verificare quali dispositivi condividono cartelle Dropbox con gli altri nodi della rete, e collegarli fra loro, riportando i risultati nella struttura \textit{dorpboxSubNET} e quindi rappresentando la \qts{sottorete} che si viene a creare fra gli utenti Dropbox.\\
	Il processo si divide in 2 fasi: nella prima si creano delle liste, raccolte nella struttura \textit{namespaces\_in\_common}, indicizzate dal \qts{codice} dei \textit{namespace} annunciati nei pacchetti \textit{db-lsp-disc}, all'interno delle quali si trovano tutti gli \textit{id} dei dispositivi che li hanno diffusi; nella seconda fase, per ogni \textit{namespace}, se ne scorre la lista di \textit{id}, per ognuno si crea un'ulteriore lista di id, nella struttura \textit{dorpboxSubNET} che come descritto in precedenza, elenca tutti i dispositivi con i quali quel nodo della rete condivide almeno una cartella.
\end{itemize}

I restanti metodi sono semplici funzioni di utilità per una stampa, formattata a linea di comando, utilizzati per visualizzare all'utente i risultati ottenuti dallo studio.\\

La classe \textbf{\textit{WhoIsWhat}} implementa tutta la parte di \textit{Analisi} delle informazioni raccolte dai pacchetti mDNS, e tenta di classificare il dispositivo dato in input al costruttore della stessa.\\
Contiene delle strutture dati di supporto, quali:\\
\textit{protos}: contiene l'insieme di tutti i \textit{tipi} dei servizi annunciati;\\
\textit{bestMatches}: insieme di categorie a cui potrebbe appartenere il dispositivo sotto analisi\\
\textit{kindPool}: dizionario che ha come indici le categorie di dispositivi, e come valore associato un intero che indica il \qts{grado di fiducia} con il quale il dispositivo appartiene a l'una o l'altra categoria.\\
\textit{kind}: Risultato dell'analisi, qui viene riportata la categoria che meglio descrive il dispositivo.\\
\textit{rel\_lev}: livello di affidabilità massimo incontrato.\\
\textit{guess\_owner}: qui viene riportato il nome dell'ipotetico proprietario ricavato dal host-name.\\
L'Algoritmo è implementato nel metodo \textbf{\textit{check()}}, e i metodi all'interno utilizzati: \textit{check\_dev\_info}, \textit{check\_on\_local\_alias} e \textit{check\_MDNS\_proto} ...
